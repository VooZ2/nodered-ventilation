[
    {
        "id": "ba9883939fe4270b",
        "type": "tab",
        "label": "Komfovent – Module: Auto-Learning",
        "disabled": false,
        "info": ""
    },
    {
        "id": "73ea89c35dffac66",
        "type": "comment",
        "z": "ba9883939fe4270b",
        "name": "Module: Auto-Learning",
        "info": "Paskirtis:\nCO₂ įjungimo slenksčio mokymasis pagal realius namų CO₂ duomenis.\n\nVeikimas:\n• CO₂ taškas kas 10 min į flow.co2_log (retention ~10 d)\n• Kasdien 03:00 LT analizuoja paskutines 24 h\n• Profilis parenkamas pagal ankstesnę parą (kad 03:00 nenaudotų „neteisingos“ dienos)\n\nApsaugos:\n• Mokosi tik kai alarm = disarmed\n• Gap Guard: jei trūksta >35% tikėtinų taškų — blokuoja\n• Stability Lock: jei max<650 arba (max-min)<100 — blokuoja\n\nLogging:\n• Pilna istorija rašoma JSONL į /data/logs/komfovent/komfovent_learning_YYYY-MM-DD.jsonl\n• Įrašai predictive-ready: ts, occupied, dow, hour, alarm, co2, profile, avgRate, delta, threshold, blocked ir pan.\n\nPastaba:\nSlenksčio šaltinis/taikinys — HA input_number.co2_on_threshold (source of truth).",
        "x": 260,
        "y": 60,
        "wires": []
    },
    {
        "id": "40811f47a04f0c4b",
        "type": "inject",
        "z": "ba9883939fe4270b",
        "name": "Scheduler: Log CO2 (10 min)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "600",
        "crontab": "",
        "once": true,
        "onceDelay": 2,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 190,
        "y": 120,
        "wires": [
            [
                "6ffb812d5b5da612"
            ]
        ]
    },
    {
        "id": "6ffb812d5b5da612",
        "type": "function",
        "z": "ba9883939fe4270b",
        "name": "Log CO2 Sample (10 min)",
        "func": "// ===== CO₂ log kaupimas (retention ~10 d) =====\n// • Skaito CO₂ ir ALARM būseną iš HA global cache\n// • Į flow.co2_log prideda tašką kas 10 min\n// • Ignoruoja netinkamas reikšmes (unknown/unavailable/NaN)\n// • Laiko max 1440 taškų (~10 dienų, jei kas 10 min)\n// • Status’e rodo paskutinę reikšmę ir log’o apimtį\n// • Papildomai paruošia predictive-ready laukus: occupied, dow, hour\n\nconst TZ = 'Europe/Vilnius';\n\nfunction isNum(v) { return v !== null && v !== undefined && isFinite(v); }\n\nfunction ltDow(ts) {\n  const wd = new Intl.DateTimeFormat('en-US', { timeZone: TZ, weekday: 'short' }).format(new Date(ts));\n  const map = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };\n  return map[wd] ?? 0;\n}\n\nfunction ltHour(ts) {\n  const parts = new Intl.DateTimeFormat('en-GB', {\n    timeZone: TZ,\n    hour: '2-digit',\n    hour12: false\n  }).formatToParts(new Date(ts));\n  const hh = parts.find(p => p.type === 'hour')?.value;\n  return Number(hh);\n}\n\nlet ha = global.get('homeassistant') || {};\nlet states =\n  (ha?.homeAssistant?.states) ||\n  (ha?.homeassistant?.states) ||\n  (ha?.states) ||\n  (global.get('homeassistant.homeAssistant.states')) ||\n  {};\n\nconst ENT_CO2 = 'sensor.oro_stotele_carbon_dioxide';\nconst ENT_ALARM = 'alarm_control_panel.home';\n\nlet stCo2 = states[ENT_CO2]?.state;\nlet co2 = parseFloat(stCo2);\n\nif (!isNum(co2)) {\n  node.status({ fill: 'red', shape: 'ring', text: `CO2 invalid: ${stCo2}` });\n  return null;\n}\n\nlet alarm = states[ENT_ALARM]?.state;\nif (alarm === undefined || alarm === null) alarm = '';\nalarm = String(alarm);\n\nconst now = Date.now();\nconst occupied = (alarm === 'disarmed');\nconst dow = ltDow(now);\nconst hour = ltHour(now);\n\nlet logs = flow.get('co2_log');\nif (!Array.isArray(logs)) logs = [];\n\nlogs.push({ ts: now, val: co2, alarm: alarm });\nwhile (logs.length > 1440) logs.shift();\nflow.set('co2_log', logs);\n\nconst first = logs[0];\nconst last = logs[logs.length - 1];\nconst spanHrs = ((last.ts - first.ts) / 3600000);\n\nnode.status({\n  fill: 'green',\n  shape: 'dot',\n  text: `CO2 ${Math.round(co2)} ppm | points ${logs.length} | span ${spanHrs.toFixed(1)}h | alarm ${alarm}`\n});\n\nmsg.payload = {\n  kind: 'co2_sample',\n  ts: now,\n  occupied: occupied,\n  dow: dow,\n  hour: hour,\n  alarm: alarm,\n  co2: Number(co2.toFixed(1))\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 120,
        "wires": [
            [
                "ed0b13e944f8159d",
                "2b74d735bcfce3d1"
            ]
        ]
    },
    {
        "id": "ed0b13e944f8159d",
        "type": "function",
        "z": "ba9883939fe4270b",
        "name": "Build Learning JSONL (append)",
        "func": "// Paruošia JSONL eilutę ir filename (daily).\n// Rašoma į: /data/logs/komfovent/komfovent_learning_YYYY-MM-DD.jsonl\n\nconst TZ = 'Europe/Vilnius';\n\nfunction ltDate(ts) {\n  const parts = new Intl.DateTimeFormat('en-GB', {\n    timeZone: TZ,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit'\n  }).formatToParts(new Date(ts));\n  const get = (t) => parts.find(p => p.type === t)?.value;\n  return `${get('year')}-${get('month')}-${get('day')}`;\n}\n\nconst p = msg.payload || {};\nconst ts = p.ts || Date.now();\nconst date = ltDate(ts);\n\nmsg.filename = `/data/logs/komfovent/komfovent_learning_${date}.jsonl`;\n\n// Užtikrinam, kad logas būtų „predictive-ready“ ir stabilus\nconst lineObj = {\n  ts: ts,\n  occupied: (p.occupied !== undefined ? !!p.occupied : null),\n  dow: (p.dow !== undefined ? p.dow : null),\n  hour: (p.hour !== undefined ? p.hour : null),\n  kind: p.kind || 'event',\n\n  // baziniai\n  alarm: (p.alarm !== undefined ? String(p.alarm) : null),\n  co2: (p.co2 !== undefined ? p.co2 : null),\n\n  // mokymosi rezultatai (jei yra)\n  profile: (p.profile !== undefined ? p.profile : null),\n  avgRate_ppmh: (p.avgRate_ppmh !== undefined ? p.avgRate_ppmh : null),\n  delta: (p.delta !== undefined ? p.delta : null),\n  threshold_prev: (p.threshold_prev !== undefined ? p.threshold_prev : null),\n  threshold_new: (p.threshold_new !== undefined ? p.threshold_new : null),\n  blocked: (p.blocked !== undefined ? !!p.blocked : null),\n  block_reasons: (p.block_reasons !== undefined ? p.block_reasons : null),\n  missing_frac: (p.missing_frac !== undefined ? p.missing_frac : null),\n  points24: (p.points24 !== undefined ? p.points24 : null),\n  pointsProfile: (p.pointsProfile !== undefined ? p.pointsProfile : null)\n};\n\nmsg.payload = JSON.stringify(lineObj) + \"\\n\";\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 120,
        "wires": [
            [
                "4bf238e36c52738e"
            ]
        ]
    },
    {
        "id": "4bf238e36c52738e",
        "type": "file",
        "z": "ba9883939fe4270b",
        "name": "Append: learning jsonl",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1070,
        "y": 120,
        "wires": [
            []
        ]
    },
    {
        "id": "2b74d735bcfce3d1",
        "type": "debug",
        "z": "ba9883939fe4270b",
        "name": "Debug (optional): CO2 sample",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 530,
        "y": 180,
        "wires": []
    },
    {
        "id": "c8db147402919181",
        "type": "inject",
        "z": "ba9883939fe4270b",
        "name": "Scheduler: Threshold Update (03:00 LT)",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "00 03 * * *",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 260,
        "y": 240,
        "wires": [
            [
                "279ba087344346b8"
            ]
        ]
    },
    {
        "id": "279ba087344346b8",
        "type": "function",
        "z": "ba9883939fe4270b",
        "name": "Compute Threshold (Profiles + Guards)",
        "func": "// ===== CO₂ slenksčio mokymasis =====\n//\n// Adaptacija vykdoma tik kai:\n// - signalizacija = disarmed\n// - nėra GAP_BLOCK (trūksta <=35% tikėtinų taškų 24h)\n// - nėra STABILITY_BLOCK (max>=650 ir range>=100)\n//\n// Profiliai:\n// - Darbo dienos: 06:00–08:00 ir 16:30–23:00 (LT)\n// - Savaitgaliai: pilnos 24h\n//\n// Source of truth:\n// - ankstesnis slenkstis skaitomas iš HA input_number.co2_on_threshold\n// - naujas slenkstis įrašomas į tą patį entity (tik jei pasikeitė)\n// - papildomai išsaugoma global (patogumui kitiems tabams)\n\nconst TZ = 'Europe/Vilnius';\nconst SAMPLE_MIN = 10;\n\nconst STABILITY_MAX_MIN = 650;\nconst STABILITY_RANGE_MIN = 100;\nconst GAP_MISSING_MAX = 0.35;\n\nconst TARGET_RATE = 60;   // ppm/h\nconst K = 0.2;\nconst DELTA_MAX = 25;\n\nconst THRESH_MIN = 550;\nconst THRESH_MAX = 950;\n\nconst ENT_ALARM = 'alarm_control_panel.home';\nconst ENT_THRESH = 'input_number.co2_on_threshold';\n\nfunction isNum(v) { return v !== null && v !== undefined && isFinite(v); }\nfunction clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }\n\nfunction ltParts(ts) {\n  const parts = new Intl.DateTimeFormat('en-GB', {\n    timeZone: TZ,\n    year: 'numeric', month: '2-digit', day: '2-digit',\n    hour: '2-digit', minute: '2-digit',\n    hour12: false\n  }).formatToParts(new Date(ts));\n  const get = (t) => parts.find(p => p.type === t)?.value;\n  return { hh: Number(get('hour')), mm: Number(get('minute')) };\n}\n\nfunction ltMinutes(ts) {\n  const p = ltParts(ts);\n  return p.hh * 60 + p.mm;\n}\n\nfunction ltDow(ts) {\n  const wd = new Intl.DateTimeFormat('en-US', { timeZone: TZ, weekday: 'short' }).format(new Date(ts));\n  const map = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };\n  return map[wd] ?? 0;\n}\n\nfunction isWeekendLT(ts) {\n  const dow = ltDow(ts);\n  return dow === 0 || dow === 6;\n}\n\nfunction inActiveWindowWeekday(ts) {\n  const m = ltMinutes(ts);\n  return (m >= 360 && m < 480) || (m >= 990 && m < 1380);\n}\n\n// HA cache (alarm + prev threshold)\nlet ha = global.get('homeassistant') || {};\nlet states =\n  (ha?.homeAssistant?.states) ||\n  (ha?.homeassistant?.states) ||\n  (ha?.states) ||\n  (global.get('homeassistant.homeAssistant.states')) ||\n  {};\n\nlet alarm = states[ENT_ALARM]?.state;\nif (alarm === undefined || alarm === null) alarm = '';\nalarm = String(alarm);\n\nconst occupied = (alarm === 'disarmed');\nconst learningBlocked = !occupied;\n\nlet prevRaw = states[ENT_THRESH]?.state;\nlet threshPrev = parseFloat(prevRaw);\nif (!isFinite(threshPrev)) threshPrev = 750;\n\n// DUOMENYS: co2_log (context)\nlet logs = flow.get('co2_log') || [];\nif (!Array.isArray(logs) || logs.length < 2) {\n  node.status({ fill: 'yellow', shape: 'ring', text: 'nepakanka duomenų' });\n  return null;\n}\n\nconst now = Date.now();\nconst start = now - 24 * 60 * 60 * 1000;\n\n// 24h validūs taškai (nepriklausomai nuo alarm) – GAP GUARD\nlet logs24_all = logs.filter(x =>\n  x && isNum(x.ts) && isNum(x.val) && x.ts >= start && x.ts <= now\n);\n\nif (logs24_all.length < 10) {\n  node.status({ fill: 'yellow', shape: 'ring', text: 'per mažai taškų (24h)' });\n  return null;\n}\n\n// 24h tik DISARMED taškai – mokymui\nlet logs24 = logs24_all.filter(x => String(x.alarm) === 'disarmed');\n\nif (logs24.length < 10) {\n  node.status({ fill: 'yellow', shape: 'ring', text: 'per mažai DISARMED taškų (24h)' });\n  return null;\n}\n\n// PROFILIS (\"vakar\" logika)\nconst referenceTs = now - 12 * 60 * 60 * 1000;\nconst weekendProfile = isWeekendLT(referenceTs);\nconst profile = weekendProfile ? 'WEEKEND_24H' : 'WEEKDAY_ACTIVE';\n\nlet logsP = weekendProfile ? logs24 : logs24.filter(p => inActiveWindowWeekday(p.ts));\n\nif (logsP.length < 6) {\n  node.status({ fill: 'yellow', shape: 'ring', text: `profilis ${profile}: per mažai taškų` });\n  return null;\n}\n\n// GAP GUARD (pagal visus valid 24h)\nconst spanMin = (logs24_all[logs24_all.length - 1].ts - logs24_all[0].ts) / 60000;\nconst expected = Math.max(1, Math.round(spanMin / SAMPLE_MIN) + 1);\nconst missingFrac = clamp(1 - (logs24_all.length / expected), 0, 1);\nlet gapBlocked = (missingFrac > GAP_MISSING_MAX);\n\n// STABILITY LOCK (pagal pasirinktą profilį)\nlet minCo2 = Infinity;\nlet maxCo2 = -Infinity;\nfor (const p of logsP) {\n  if (p.val < minCo2) minCo2 = p.val;\n  if (p.val > maxCo2) maxCo2 = p.val;\n}\nconst range = maxCo2 - minCo2;\nlet stabilityBlocked = (maxCo2 < STABILITY_MAX_MIN) || (range < STABILITY_RANGE_MIN);\n\n// AVG RISING RATE (ppm/h)\nlet sumRate = 0;\nlet cnt = 0;\nlet skippedGaps = 0;\n\nfor (let i = 1; i < logsP.length; i++) {\n  let dtMin = (logsP[i].ts - logsP[i - 1].ts) / 60000;\n  if (dtMin <= 0 || dtMin > 20) {\n    skippedGaps++;\n    continue;\n  }\n  let dCo2 = logsP[i].val - logsP[i - 1].val;\n  if (dCo2 > 0) {\n    sumRate += (dCo2 / dtMin) * 60;\n    cnt++;\n  }\n}\n\nlet avgRate = cnt ? (sumRate / cnt) : 0;\n\n// Proporcinė adaptacija\nlet difference = avgRate - TARGET_RATE;\nlet delta = -Math.round(difference * K);\ndelta = clamp(delta, -DELTA_MAX, DELTA_MAX);\n\nlet blocked = gapBlocked || stabilityBlocked || learningBlocked;\nlet thresh = threshPrev;\n\nif (!blocked) {\n  thresh = Math.round(threshPrev + delta);\n  thresh = clamp(thresh, THRESH_MIN, THRESH_MAX);\n} else {\n  delta = 0;\n}\n\n// Išsaugojimas global – patogu kitiems tabams\n// (paliekam abu raktus, kad nesulaužytų senesni moduliai)\nglobal.set('komfovent.auto_co2_on_threshold', thresh);\nglobal.set('auto_co2_on_threshold', thresh);\n\n// Status\nlet statusBits = [];\nstatusBits.push(profile);\nstatusBits.push(`avg ${avgRate.toFixed(1)} ppm/h`);\nstatusBits.push(`delta ${delta}`);\nstatusBits.push(`thr ${Math.round(threshPrev)}->${Math.round(thresh)}`);\nstatusBits.push(`miss ${(missingFrac * 100).toFixed(0)}%`);\n\nif (gapBlocked) statusBits.push('GAP_BLOCK');\nif (stabilityBlocked) statusBits.push('STABILITY_BLOCK');\nif (learningBlocked) statusBits.push('ALARM_BLOCK');\n\nnode.status({\n  fill: blocked ? 'yellow' : 'green',\n  shape: blocked ? 'ring' : 'dot',\n  text: statusBits.join(' | ')\n});\n\n// Output payload'ui (JSONL logui)\nconst dow = ltDow(now);\nconst hour = ltParts(now).hh;\n\n// ar realiai pasikeitė slenkstis?\nconst threshold_changed = (!blocked) && (Math.round(thresh) !== Math.round(threshPrev));\nmsg.threshold_changed = threshold_changed;\n\n// JSONL event'as visada (net jei blocked) – audito tikslais\nmsg.payload = {\n  kind: 'threshold_update',\n  ts: now,\n  occupied: occupied,\n  dow: dow,\n  hour: hour,\n  alarm: alarm,\n  profile: profile,\n  avgRate_ppmh: Number(avgRate.toFixed(2)),\n  delta: delta,\n  threshold_prev: Math.round(threshPrev),\n  threshold_new: Math.round(thresh),\n  blocked: blocked,\n  block_reasons: { gapBlocked: gapBlocked, stabilityBlocked: stabilityBlocked, learningBlocked: learningBlocked },\n  missing_frac: Number(missingFrac.toFixed(4)),\n  points24: logs24_all.length,\n  pointsProfile: logsP.length,\n  debug: { skippedGaps: skippedGaps }\n};\n\n// HA write tik jei pasikeitė ir nėra blokų\nmsg.ha = threshold_changed ? { entity_id: ENT_THRESH, value: Math.round(thresh) } : null;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 240,
        "wires": [
            [
                "554f364405faadbb",
                "8397a434ed153a0f"
            ]
        ]
    },
    {
        "id": "554f364405faadbb",
        "type": "function",
        "z": "ba9883939fe4270b",
        "name": "Tap: Threshold Log → JSONL",
        "func": "// JSONL rašom VISADA (threshold_update), net jei blocked.\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 240,
        "wires": [
            [
                "ed0b13e944f8159d"
            ]
        ]
    },
    {
        "id": "8397a434ed153a0f",
        "type": "switch",
        "z": "ba9883939fe4270b",
        "name": "HA Gate: Only When Changed",
        "property": "threshold_changed",
        "propertyType": "msg",
        "rules": [
            {
                "t": "true"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 920,
        "y": 300,
        "wires": [
            [
                "12f1e0f705e1c62e",
                "a4c0dee9e727b315"
            ]
        ]
    },
    {
        "id": "a4c0dee9e727b315",
        "type": "function",
        "z": "ba9883939fe4270b",
        "name": "Build threshold_changed → JSONL",
        "func": "// Atskiras eventas tik tada, kai threshold realiai pasikeitė\nif (msg.threshold_changed !== true) return null;\n\nconst p = msg.payload || {};\n\nmsg.payload = {\n  kind: 'threshold_changed',\n  ts: p.ts,\n  occupied: p.occupied,\n  dow: p.dow,\n  hour: p.hour,\n  alarm: p.alarm,\n  profile: p.profile,\n  threshold_prev: p.threshold_prev,\n  threshold_new: p.threshold_new,\n  delta: p.delta\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 200,
        "wires": [
            [
                "ed0b13e944f8159d"
            ]
        ]
    },
    {
        "id": "12f1e0f705e1c62e",
        "type": "api-call-service",
        "z": "ba9883939fe4270b",
        "name": "HA Call: input_number.set_value",
        "server": "de0e06cd.8456e8",
        "version": 7,
        "debugenabled": false,
        "action": "",
        "floorId": [],
        "areaId": [],
        "deviceId": [],
        "entityId": [],
        "labelId": [],
        "data": "{\"entity_id\":\"{{ha.entity_id}}\",\"value\":{{ha.value}}}",
        "dataType": "json",
        "mergeContext": "",
        "mustacheAltTags": false,
        "outputProperties": [],
        "queue": "none",
        "blockInputOverrides": false,
        "domain": "input_number",
        "service": "set_value",
        "x": 1290,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "de0e06cd.8456e8",
        "type": "server",
        "name": "Home Assistant",
        "version": 6,
        "addon": false,
        "rejectUnauthorizedCerts": false,
        "ha_boolean": [
            "y",
            "yes",
            "true",
            "on",
            "home",
            "open"
        ],
        "connectionDelay": true,
        "cacheJson": true,
        "heartbeat": false,
        "heartbeatInterval": "30",
        "areaSelector": "friendlyName",
        "deviceSelector": "friendlyName",
        "entitySelector": "friendlyName",
        "statusSeparator": "at: ",
        "statusYear": "hidden",
        "statusMonth": "short",
        "statusDay": "numeric",
        "statusHourCycle": "h23",
        "statusTimeFormat": "h:m",
        "enableGlobalContextStore": true
    },
    {
        "id": "aae97ae05e107f2b",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-contrib-home-assistant-websocket": "0.80.3"
        }
    }
]